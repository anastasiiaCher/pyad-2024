from typing import List, Optional, Tuple
import numpy as np
import scipy as sc
from scipy.optimize import fmin


def matrix_multiplication(matrix_a, matrix_b):
    """
    Задание 1. Функция для перемножения матриц с помощью списков и циклов.
    Вернуть нужно матрицу в формате списка.
    """
    # Проверяем, можно ли умножить матрицы (количество столбцов первой матрицы должно быть равно количеству строк второй матрицы)
    if len(matrix_a[0]) != len(matrix_b):
        raise ValueError("Количество столбцов первой матрицы должно быть равно количеству строк второй матрицы")

    # Инициализируем результатирующую матрицу нулями
    result = [[0 for _ in range(len(matrix_b[0]))] for _ in range(len(matrix_a))]

    # Выполняем умножение матриц
    for i in range(len(matrix_a)):
        for j in range(len(matrix_b[0])):
            for k in range(len(matrix_b)):
                result[i][j] += matrix_a[i][k] * matrix_b[k][j]

    return result


def functions(a_1: str, a_2: str) -> Optional[List[Tuple[float, float]]]:
    """
    На вход поступают две строки, содержащие коэффициенты двух функций.
    Необходимо найти точки экстремума функций и определить, есть ли у функций общие решения.
    Вернуть нужно координаты найденных решений списком, если они есть. None, если их бесконечно много.
    """
    # Преобразуем строки с коэффициентами в списки чисел с плавающей точкой
    coef1: List[float] = list(map(float, a_1.split()))
    coef2: List[float] = list(map(float, a_2.split()))
    a11, a12, a13 = coef1  # Коэффициенты первой функции F(x)
    a21, a22, a23 = coef2  # Коэффициенты второй функции P(x)

    # Если коэффициенты обеих функций совпадают, решений бесконечно много
    if coef1 == coef2:
        return None

    # Функции для вычисления значения функции по x
    func1 = lambda x: a11 * x ** 2 + a12 * x + a13
    func2 = lambda x: a21 * x ** 2 + a22 * x + a23

    # Находим точки экстремума для обеих функций
    extremum_F: float = fmin(func1, 0, disp=False)[0]
    extremum_P: float = fmin(func2, 0, disp=False)[0]

    # Параметры для нахождения пересечений функций: A * x^2 + B * x + C = 0
    A, B, C = a11 - a21, a12 - a22, a13 - a23

    # Если все коэффициенты A, B, C равны 0, то функции совпадают
    if A == 0 and B == 0 and C == 0:
        return None

    # Если A и B равны 0, а C не равно 0, функций параллельны — решений нет
    if A == 0 and B == 0 and C != 0:
        return []

    # Если A равно 0, уравнение становится линейным
    if A == 0:
        return [(round(-C / B, 2), round(func1(-C / B), 2))] if B != 0 else []

    # Вычисляем дискриминант для квадратного уравнения
    discriminant: float = B ** 2 - 4 * A * C

    # Если дискриминант меньше 0, пересечений нет
    if discriminant < 0:
        return []

    # Если дискриминант равен 0, одно решение (касание функций)
    if discriminant == 0:
        x = -B / (2 * A)
        return [(round(x, 2), round(func1(x), 2))]

    # Если дискриминант больше 0, два решения (пересечение функций)
    sqrt_d = np.sqrt(discriminant)
    x1, x2 = (-B + sqrt_d) / (2 * A), (-B - sqrt_d) / (2 * A)
    return [(round(x1, 2), round(func1(x1), 2)), (round(x2, 2), round(func1(x2), 2))]


def skew(x):
    """
    Задание 3. Функция для расчета коэффициента асимметрии.
    Необходимо вернуть значение коэффициента асимметрии, округленное до 2 знаков после запятой.
    """
    # Количество элементов в выборке
    n = len(x)

    mean_x = np.mean(x)  # Вычисляем выборочное среднее
    m2 = np.sum((x - mean_x) ** 2) / n  # Вычисляем дисперсию (момент второго порядка)
    m3 = np.sum((x - mean_x) ** 3) / n  # Вычисляем четвертый центральный момент (момент четвертого порядка)
    sigma = np.sqrt(m2)  # Стандартное отклонение
    kurtosis_value = m3 / sigma ** 3   # Коэффициент эксцесса (kurtosis), скорректированный на 3

    # Округляем результат до 2 знаков после запятой
    return round(kurtosis_value, 2)


def kurtosis(x):
    """
    Задание 3. Функция для расчета коэффициента эксцесса.
    Необходимо вернуть значение коэффициента эксцесса, округленное до 2 знаков после запятой.
    """
    n = len(x)

    mean_x = np.mean(x) # Вычисляем выборочное среднее
    m2 = np.sum((x - mean_x) ** 2) / n # Вычисляем дисперсию (момент второго порядка)
    m4 = np.sum((x - mean_x) ** 4) / n # Вычисляем четвертый центральный момент (момент четвертого порядка)
    sigma = np.sqrt(m2) # Стандартное отклонение
    kurtosis_value = m4 / sigma ** 4 - 3 # Коэффициент эксцесса (kurtosis), скорректированный на 3

    # Округляем результат до 2 знаков после запятой
    return round(kurtosis_value, 2)