# -*- coding: utf-8 -*-
"""Копия блокнота "lab_0.ipynb"

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1a25rJA0RnD-VZa1muLYbcD4vg2Gwocof

### Задача 1 – Умножение матриц

Напишите функцию для умножения матриц, используя только списки и циклы.

Не забывайте проверить, что умножение выполнить возможно.
Напомним, что две матрицы могут быть перемножены, если число столбцов первой матрицы равно числу строк второй матрицы. Если матрица
$A$ имеет размер $m×n$ ($m$ строк и $nя$ столбцов), а матрица $B$ имеет размер $n×p$, то их произведение $C=AB$ будет иметь размер $m×p$.

Если $A=(a_{ij})$ — матрица размера $m×n$, а $B=(b_{jk})$ — матрица размера $n×p$, то элемент $c_{ik}$ матрицы $C=AB$ вычисляется по формуле:

$$c_{ik}=\sum_{j=1}^{n}a_{ij}b_{jk}$$

То есть каждый элемент новой матрицы является суммой произведений соответствующих элементов строки первой матрицы и столбца второй.
"""

import numpy as np

matrix1 = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
matrix2 = np.array([[9, 8, 7], [6, 5, 4], [3, 2, 1]])

print("Произведение матриц:")
matrix1 @ matrix2

"""### Задача 2 – Функции

Дано две функции:

\begin{matrix} F(x) = a_{11}x^2 + a_{12}x + a_{13}&(1) \\ P(x) = a_{21}x^2+a_{22}x + a_{23} &(2) \end{matrix}
​
* На вход программа должна принимать 2 строки. Каждая строка содержит 3 действительных числа через пробел: коэффициенты $a$.
* Необходимо найти точки экстремума функций (например, через функцию [`minimize_scalar()`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize_scalar.html), [`fmin()`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.fmin.html) и др.) и определить, есть ли у функций общие решения при введенных коэффициентах на некотором диапазоне значений $x$, предусмотрев ситуации, когда решения есть, решений нет и решений бесконечно много.

### Задача 3 – Коэффициент асимметрии и эксцесса

Напишите функцию, которая для случайной выборки рассчитывает коэффициенты асимметрии и эксцесса.

Коэффициент асимметрии:

$$A_3=\frac{m_3}{\sigma^3}$$

Коэффициент эксцесса:

$$E_4=\frac{m_4}{\sigma^4}-3$$

С помощью этих коэффициентов можно прикинуть, насколько близко распределение выборки к нормальному. Для расчета этих коэффициентов понадобится рассчитать центральные моменты третьего ($m_3$) и четвертого ($m_4$) порядка. Основные формулы, которые понадобятся для расчетов:
1. Момент второго порядка (он же – дисперсия):
$$m_2=D_e=\frac{∑(x_i-\overline{x_e})^2\times n_i}{n}$$
2. Момент третьего порядка:
$$m_3=\frac{∑(x_i-\overline{x_e})^3\times n_i}{n}$$
3. Момент четвертого порядка:
$$m_4=\frac{∑(x_i-\overline{x_e})^4\times n_i}{n}$$

В формулах выше $\overline{x_e}$ – это выборочное среднее.
$$\overline{x_e}=\frac{∑(x_i\times n_i)}{n},$$
где $x_i$ – $i$-е значение из выборки, $n_i$ – число раз, когда $x_i$ встретилось в выборке, $n$ – объем выборки.


Проверить корректность расчетов можно с помощью функции [`kurtosis`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.kurtosis.html) для коэффициента эксцесса и функции [`skew`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.kurtosis.html) из `scipy`.

**Коэффициент асимметрии** количественно определяет степень асимметрии распределения. Он показывает, в какую сторону распределение скошено относительно своего среднего значения.

1. Если коэффициент асимметрии больше 0, это означает, что "длинная часть" распределения находится справа от среднего (правостороннее распределение). Это может указывать на наличие выбросов или значений, превышающих среднее.
2. Если коэффициент меньше 0, "длинная часть" находится слева от среднего (левостороннее распределение). Это может свидетельствовать о большем количестве низких значений.
3. Коэффициент равен 0, что указывает на симметрию вокруг среднего значения.



**Эксцесс** измеряет остроту распределения по сравнению с нормальным распределением и показывает, насколько вероятны выбросы в данных.

1. Если эксцесс положителен (больше 0), это указывает на более острый пик и более тяжелые хвосты по сравнению с нормальным распределением. Это означает, что в данных больше выбросов.
2. Если эксцесс равен 0, это соответствует нормальному распределению, где пики и хвосты находятся на стандартном уровне.
3. Если эксцесс отрицателен (меньше 0), это говорит о более плоском пике и легких хвостах, что указывает на меньшую вероятность выбросов.
"""

from scipy.stats import kurtosis, skew

kurtosis([2,3,5,7,8]), skew([2,3,5,7,8])

kurtosis([2,3,2,5,7,2,2,8]), skew([2,3,2,5,7,2,2,8])

import matplotlib.pyplot as plt
import seaborn as sns

sns.histplot([2,3,2,5,7,2,2,8], kde=True);

"""### Куда и как сдавать работу?

По инструкции в гитхаб – https://shy-question-39d.notion.site/1150ea832e418032bfc3d3e827c380fb?pvs=74

**Устная защита работ не требуется, но вам могут быть заданы вопросы прямо в вашем пул-реквесте!**

Выполнение задачи 1
"""

def matrix_multiplication(A, B):
    # Проверка возможности перемножения матриц
    if len(A[0]) != len(B):
        raise ValueError("Матрицы нельзя перемножить, так как число столбцов первой матрицы не равно числу строк второй матрицы.")

    # Получение размеров результирующей матрицы
    m, n, p = len(A), len(A[0]), len(B[0])

    # Инициализация результирующей матрицы нулями
    result = [[0 for _ in range(p)] for _ in range(m)]

    # Умножение матриц
    for i in range(m):
        for k in range(p):
            for j in range(n):
                result[i][k] += A[i][j] * B[j][k]

    return result


# Проверка результата умножения матриц
# A = [[1, 2, 3],
#      [4, 5, 6],
#      [7, 8, 9]]

# B = [[9, 8, 7],
#      [6, 5, 4],
#      [3, 2, 1]]

# result = matrix_multiply(A, B)
# for row in result:
#     print(row)


# Проверка возникновения ошибки при перемножении матриц
# C = [[1, 2, 3],
#      [4, 5, 6],
#      [7, 8, 9]]

# D = [[9, 8, 7],
#      [6, 5, 4]]

# result = matrix_multiply(C, D)
# for row in result:
#     print(row)

"""Выполнение задачи 2"""

from scipy.optimize import minimize_scalar
from sympy import symbols, Eq, solve, im

def parse_coefficients(input_str):
    # Разбитие строки на три коэффициента и преобразование во float
    return list(map(float, input_str.split()))

def find_extremum(a1, a2, a3):
    # Функция для нахождения экстремума квадратичной функции F(x) = a1*x^2 + a2*x + a3
    def func(x):
        return a1 * x**2 + a2 * x + a3

    # Поиск экстремума
    result = minimize_scalar(func)
    # Округление до двух знаков после запятой для точности
    return round(result.x, 2), round(func(result.x), 2)

def find_common_solutions(a, b):
    if a == b:
        return "бесконечно много (функции идентичны)"

    # Решение уравнения F(x) = P(x)
    x = symbols('x')

    F = a[0]*x**2 + a[1]*x + a[2]
    P = b[0]*x**2 + b[1]*x + b[2]

    equation = Eq(F, P)
    solutions = solve(equation, x)

    # Фильтрация только вещественных решения
    real_solutions = [sol.evalf() for sol in solutions if im(sol) == 0]

    # Округление каждого решения до 2 знаков после запятой для точности
    rounded_solutions = [sol.evalf(2) for sol in real_solutions]

    return rounded_solutions

def functions(coeffs1, coeffs2):
    # Преобразование входных строк в коэффициенты
    a = parse_coefficients(coeffs1)
    b = parse_coefficients(coeffs2)

    # Решение уравнения F(x) = P(x)
    solutions = find_common_solutions(a, b)

    # Возврат результатов
    if isinstance(solutions, str):  # Бесконечное число решений
        return None
    else:
        return solutions

"""Выполнение задачи 3"""

def calculate_moments(data):
    n = len(data)
    if n == 0:
        raise ValueError("Выборка не должна быть пустой.")

    # Выборочное среднее
    x_bar = np.sum(data) / n

    # Момент второго порядка (дисперсия)
    m2 = np.sum((data - x_bar) ** 2) / n

    # Момент третьего порядка
    m3 = np.sum((data - x_bar) ** 3) / n

    # Момент четвертого порядка
    m4 = np.sum((data - x_bar) ** 4) / n

    return m2, m3, m4

def calculate_skewness(data):
    m2, m3, _ = calculate_moments(data)

    # Стандартное отклонение
    sigma = np.sqrt(m2)

    # Коэффициент асимметрии
    A3 = m3 / (sigma ** 3) if sigma != 0 else 0

    return round(A3, 2)

def calculate_excess(data):
    m2, _, m4 = calculate_moments(data)

    # Стандартное отклонение
    sigma = np.sqrt(m2)

    # Коэффициент эксцесса
    E4 = m4 / (sigma ** 4) - 3 if sigma != 0 else 0

    return round(E4, 2)

# # Пример использования
# if __name__ == "__main__":
#     # # Проверка с данными выборками
#     # sample_data = [2,3,5,7,8]
#     # sample_data = [2,3,2,5,7,2,2,8]
#     # Генерация случайной выборки
#     sample_data = np.random.normal(loc=0, scale=1, size=1000)

#     # Расчет коэффициентов асимметрии и эксцесса
#     skewness, excess = calculate_skewness_excess(sample_data)

#     print(f"Коэффициент асимметрии: {skewness}")
#     print(f"Коэффициент эксцесса: {excess}")

#     # Проверка с использованием scipy
#     print(f"Коэффициент асимметрии (skew): {skew(sample_data)}")
#     print(f"Коэффициент эксцесса (kurtosis): {kurtosis(sample_data)}")